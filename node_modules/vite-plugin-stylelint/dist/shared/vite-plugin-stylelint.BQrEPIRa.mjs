import { createFilter, normalizePath } from '@rollup/pluginutils';

const STYLELINT_SEVERITY = {
  ERROR: "error",
  WARNING: "warning"
};
const PLUGIN_NAME = "vite:stylelint";
const COLOR_MAPPING = {
  error: "red",
  warning: "yellow",
  plugin: "magenta"
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var picocolors = {exports: {}};

var hasRequiredPicocolors;

function requirePicocolors () {
	if (hasRequiredPicocolors) return picocolors.exports;
	hasRequiredPicocolors = 1;
	let p = process || {}, argv = p.argv || [], env = p.env || {};
	let isColorSupported =
		!(!!env.NO_COLOR || argv.includes("--no-color")) &&
		(!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || ((p.stdout || {}).isTTY && env.TERM !== "dumb") || !!env.CI);

	let formatter = (open, close, replace = open) =>
		input => {
			let string = "" + input, index = string.indexOf(close, open.length);
			return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close
		};

	let replaceClose = (string, close, replace, index) => {
		let result = "", cursor = 0;
		do {
			result += string.substring(cursor, index) + replace;
			cursor = index + close.length;
			index = string.indexOf(close, cursor);
		} while (~index)
		return result + string.substring(cursor)
	};

	let createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1b[0m", "\x1b[0m"),
			bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
			dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
			italic: f("\x1b[3m", "\x1b[23m"),
			underline: f("\x1b[4m", "\x1b[24m"),
			inverse: f("\x1b[7m", "\x1b[27m"),
			hidden: f("\x1b[8m", "\x1b[28m"),
			strikethrough: f("\x1b[9m", "\x1b[29m"),

			black: f("\x1b[30m", "\x1b[39m"),
			red: f("\x1b[31m", "\x1b[39m"),
			green: f("\x1b[32m", "\x1b[39m"),
			yellow: f("\x1b[33m", "\x1b[39m"),
			blue: f("\x1b[34m", "\x1b[39m"),
			magenta: f("\x1b[35m", "\x1b[39m"),
			cyan: f("\x1b[36m", "\x1b[39m"),
			white: f("\x1b[37m", "\x1b[39m"),
			gray: f("\x1b[90m", "\x1b[39m"),

			bgBlack: f("\x1b[40m", "\x1b[49m"),
			bgRed: f("\x1b[41m", "\x1b[49m"),
			bgGreen: f("\x1b[42m", "\x1b[49m"),
			bgYellow: f("\x1b[43m", "\x1b[49m"),
			bgBlue: f("\x1b[44m", "\x1b[49m"),
			bgMagenta: f("\x1b[45m", "\x1b[49m"),
			bgCyan: f("\x1b[46m", "\x1b[49m"),
			bgWhite: f("\x1b[47m", "\x1b[49m"),

			blackBright: f("\x1b[90m", "\x1b[39m"),
			redBright: f("\x1b[91m", "\x1b[39m"),
			greenBright: f("\x1b[92m", "\x1b[39m"),
			yellowBright: f("\x1b[93m", "\x1b[39m"),
			blueBright: f("\x1b[94m", "\x1b[39m"),
			magentaBright: f("\x1b[95m", "\x1b[39m"),
			cyanBright: f("\x1b[96m", "\x1b[39m"),
			whiteBright: f("\x1b[97m", "\x1b[39m"),

			bgBlackBright: f("\x1b[100m", "\x1b[49m"),
			bgRedBright: f("\x1b[101m", "\x1b[49m"),
			bgGreenBright: f("\x1b[102m", "\x1b[49m"),
			bgYellowBright: f("\x1b[103m", "\x1b[49m"),
			bgBlueBright: f("\x1b[104m", "\x1b[49m"),
			bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
			bgCyanBright: f("\x1b[106m", "\x1b[49m"),
			bgWhiteBright: f("\x1b[107m", "\x1b[49m"),
		}
	};

	picocolors.exports = createColors();
	picocolors.exports.createColors = createColors;
	return picocolors.exports;
}

var picocolorsExports = /*@__PURE__*/ requirePicocolors();
const pico = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

const getOptions = ({
  test,
  dev,
  build,
  cache,
  include,
  exclude,
  stylelintPath,
  formatter,
  lintInWorker,
  lintOnStart,
  lintDirtyOnly,
  emitError,
  emitErrorAsWarning,
  emitWarning,
  emitWarningAsError,
  ...stylelintOptions
}) => ({
  test: test ?? false,
  dev: dev ?? true,
  build: build ?? false,
  cache: cache ?? true,
  include: include ?? ["src/**/*.{css,scss,sass,less,styl,vue,svelte}"],
  exclude: exclude ?? ["node_modules", "virtual:"],
  stylelintPath: stylelintPath ?? "stylelint",
  formatter: formatter ?? "string",
  lintInWorker: lintInWorker ?? false,
  lintOnStart: lintOnStart ?? false,
  lintDirtyOnly: lintDirtyOnly ?? true,
  emitError: emitError ?? true,
  emitErrorAsWarning: emitErrorAsWarning ?? false,
  emitWarning: emitWarning ?? true,
  emitWarningAsError: emitWarningAsError ?? false,
  ...stylelintOptions
});
const getFilter = (options) => createFilter(options.include, options.exclude);
const initializeStylelint = async (options) => {
  const { stylelintPath, formatter } = options;
  try {
    const module = await import(stylelintPath);
    const stylelintInstance = module?.default ?? module;
    const loadedFormatter = typeof formatter === "string" ? await stylelintInstance.formatters[formatter] : formatter;
    return { stylelintInstance, formatter: loadedFormatter };
  } catch (error) {
    throw new Error(
      `Failed to initialize Stylelint. Have you installed and configured correctly? ${error}`
    );
  }
};
const getStylelintLinterOptions = (options) => ({
  ...options,
  allowEmptyInput: true
});
const isVirtualModule = (id) => id.startsWith("virtual:") || id[0] === "\0" || !id.includes("/");
const getFilePath = (id) => normalizePath(id).split("?")[0];
const shouldIgnoreModule = (id, filter) => {
  if (isVirtualModule(id)) return true;
  if (!filter(id)) return true;
  const filePath = getFilePath(id);
  if ([".vue", ".svelte"].some((extname) => filePath.endsWith(extname))) {
    return !(id.includes("?") && id.includes("type=style"));
  }
  return false;
};
const colorize = (text, textType) => pico[COLOR_MAPPING[textType]](text);
const log = (text, textType, context) => {
  console.log("");
  if (context) {
    if (textType === "error") context.error(text);
    else if (textType === "warning") context.warn(text);
  } else {
    console.log(`${text}  Plugin: ${colorize(PLUGIN_NAME, "plugin")}\r
`);
  }
};
const lintFiles = async ({ files, stylelintInstance, formatter, options }, context) => await stylelintInstance.lint({ ...getStylelintLinterOptions(options), files }).then(async (linterResult) => {
  if (!linterResult || linterResult.results.length === 0) return;
  let results = linterResult.results.filter((item) => !item.ignored);
  if (!options.emitError) {
    results = results.map((item) => ({
      ...item,
      warnings: item.warnings.filter(
        (warning) => warning.severity !== STYLELINT_SEVERITY.ERROR
      )
    }));
    linterResult.errored = false;
  }
  if (!options.emitWarning) {
    results = results.map((item) => ({
      ...item,
      warnings: item.warnings.filter(
        (warning) => warning.severity !== STYLELINT_SEVERITY.WARNING
      )
    }));
  }
  results = results.filter((item) => item.warnings.length > 0);
  if (results.length === 0) return;
  linterResult.results = results;
  const formattedText = formatter(results, linterResult);
  const formattedTextType = linterResult.errored ? options.emitErrorAsWarning ? "warning" : "error" : options.emitWarningAsError ? "error" : "warning";
  return log(formattedText, formattedTextType, context);
});

export { PLUGIN_NAME as P, getFilter as a, getFilePath as b, getOptions as g, initializeStylelint as i, lintFiles as l, shouldIgnoreModule as s };
