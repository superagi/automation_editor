"use strict";(()=>{var h=Object.defineProperty;var v=(i,e,t)=>e in i?h(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var o=(i,e,t)=>v(i,typeof e!="symbol"?e+"":e,t);var l=class{constructor(){o(this,"_eventListeners");o(this,"_maxListeners");this._eventListeners=new Map,this._maxListeners=100}once(e,t){let s=(...n)=>{this.off(e,s),t(...n)};return this.on(e,s),this}listenerCount(e){if(!e)return this.getAllListeners().length;let t=this._eventListeners.get(e);return t?t.length:0}eventNames(){return Array.from(this._eventListeners.keys())}rawListeners(e){return e?this._eventListeners.get(e)??[]:this.getAllListeners()}prependListener(e,t){let s=this._eventListeners.get(e)??[];return s.unshift(t),this._eventListeners.set(e,s),this}prependOnceListener(e,t){let s=(...n)=>{this.off(e,s),t(...n)};return this.prependListener(e,s),this}maxListeners(){return this._maxListeners}addListener(e,t){return this.on(e,t),this}on(e,t){this._eventListeners.has(e)||this._eventListeners.set(e,[]);let s=this._eventListeners.get(e);return s&&(s.length>=this._maxListeners&&console.warn(`MaxListenersExceededWarning: Possible event memory leak detected. ${s.length+1} ${e} listeners added. Use setMaxListeners() to increase limit.`),s.push(t)),this}removeListener(e,t){return this.off(e,t),this}off(e,t){let s=this._eventListeners.get(e)??[],n=s.indexOf(t);return n!==-1&&s.splice(n,1),s.length===0&&this._eventListeners.delete(e),this}emit(e,...t){let s=!1,n=this._eventListeners.get(e);if(n&&n.length>0)for(let r of n)r(...t),s=!0;return s}listeners(e){return this._eventListeners.get(e)??[]}removeAllListeners(e){return e?this._eventListeners.delete(e):this._eventListeners.clear(),this}setMaxListeners(e){this._maxListeners=e;for(let t of this._eventListeners.values())t.length>e&&t.splice(e)}getAllListeners(){let e=new Array;for(let t of this._eventListeners.values())e=e.concat(t);return e}};var a=class extends l{constructor(){super();o(this,"_hooks");this._hooks=new Map}onHook(t,s){let n=this._hooks.get(t);n?n.push(s):this._hooks.set(t,[s])}prependHook(t,s){let n=this._hooks.get(t);n?n.unshift(s):this._hooks.set(t,[s])}prependOnceHook(t,s){let n=async(...r)=>(this.removeHook(t,n),s(...r));this.prependHook(t,n)}onceHook(t,s){let n=async(...r)=>(this.removeHook(t,n),s(...r));this.onHook(t,n)}removeHook(t,s){let n=this._hooks.get(t);if(n){let r=n.indexOf(s);r!==-1&&n.splice(r,1)}}async hook(t,...s){let n=this._hooks.get(t);if(n)for(let r of n)try{await r(...s)}catch(m){this.emit("error",new Error(`Error in hook handler for event "${t}": ${m.message}`))}}get hooks(){return this._hooks}getHooks(t){return this._hooks.get(t)}clearHooks(){this._hooks.clear()}};})();
//# sourceMappingURL=index.global.js.map